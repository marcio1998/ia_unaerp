# -*- coding: utf-8 -*-
"""monte_carlo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LsPCw2LDSS2sPqdg7Fk2ao5BUIfRFOnz
"""

import numpy as np
import pandas as pd
df = pd.DataFrame()
df_1 = pd.DataFrame()
df_2 = pd.DataFrame()
np.random.seed(123)

E1 = [0,0,1,1]
E2 = [0,1,0,1]
saida = [0.0,1.0,1.0,0.0]
tx = 0.0001
erro_inicial = 0.0
B = 10

def manipular_peso_trash_hold(matriz):
  if matriz.shape[0] == 2:
    for i in range(matriz.shape[0]):
      for j in range(matriz.shape[1]):
        matriz[i][j] =  (matriz[i][j]*40) -20 
  else:
    for i in range(matriz.shape[0]):
      matriz[i] = (matriz[i]*40)-20

def passo(matriz):
  matriz_1 =  np.random.rand(2,3)
  matriz_2 = np.random.rand(3)
  peso = np.random.rand(1)
  #print(matriz)
  if matriz.shape[0] == 2:
    matriz_retorno = np.zeros((2,3))
    for i in range(matriz.shape[0]):
      for j in range(matriz.shape[1]):
        matriz_retorno[i][j] = matriz[i][j] + ((matriz_1[i][j]*2)-1)
    return matriz_retorno
  else:
    matriz_retorno = np.zeros((3))
    for i in range(matriz.shape[0]):
      matriz_retorno[i] = matriz[i] + ((matriz_2[i]*2)-1)
    return matriz_retorno

def atualizar_array(matriz_1, matriz_2):
  if matriz_1.shape[0] == 2:
    for i in range(matriz_1.shape[0]):
      for j in range(matriz_1.shape[1]):
        matriz_1[i][j] = matriz_2[i][j] 
  else:
    for i in range(matriz_1.shape[0]):
      matriz_1[i] = matriz_2[i]

w1 = np.random.rand(2,3)
w2 = np.random.rand(3)
manipular_peso_trash_hold(w1)
manipular_peso_trash_hold(w2)
I = np.zeros((3,3))
O = np.zeros((3,3))
for i in range(len(E1)):
  #I1 - copia dos dados de entrada.
  I[0][0] = E1[i]
  I[0][1] = E2[i]
  I[0][2] = 1.0 # Constante.
  #Copia para os Outputs
  O[0][0] = I[0][0]
  O[0][1] = I[0][1]
  O[0][2] = I[0][2]
  #Calculo Para as entradas da segunda camada.
  I[1][0] = O[0][0]*w1[0][0] + O[0][1]*w1[0][1] + O[0][2]*w1[0][2]
  I[1][1] = O[0][0]*w1[1][0] + O[0][1]*w1[1][1] + O[0][2]*w1[1][2]
  I[1][2] = 1.0 # constante.
  #Calculo do Exp para trash_hold.
  O[1][0] = 1.0/(1.0+np.exp(-I[1][0]))
  O[1][1] = 1.0/(1.0+np.exp(-I[1][1]))
  O[1][2] = I[1][2]
  #calculo da ultima entrada
  I[2][0] = O[1][0]*w2[0] + O[1][1]*w2[1] + O[1][2]*w2[2]
  #Calculo da ultima saida
  O[2][0] = 1.0/(1.0+np.exp(-I[2][0]))
  erro_inicial += float(pow((saida[i]-O[2][0]),2))
erro_inicial *= 0.5
peso_comparar_1 = []
peso_comparar_2 = []
peso_comparar_3 = []
for i in range(w1.shape[1]):
  peso_comparar_1.append(w1[0][i])
  peso_comparar_2.append(w1[1][i])
  peso_comparar_3.append(w2[i])
print(erro_inicial)
print(w1)
print(w2)

erro = 1.0
n = 0.0
while erro > tx:
  diferenca_erro = 0.0
  erro = 0.0
  saidas = []
  w1_copia = passo(w1)
  w2_copia = passo(w2)
  #print(w1_copia)
  #print(w2_copia)
  #print('----------------')
  I = np.zeros((3,3))
  O = np.zeros((3,3))
  for i in range(len(E1)):
    #I1 - copia dos dados de entrada.
    I[0][0] = E1[i]
    I[0][1] = E2[i]
    I[0][2] = 1.0 # Constante.
    #Copia para os Outputs
    O[0][0] = I[0][0]
    O[0][1] = I[0][1]
    O[0][2] = I[0][2]
    #Calculo Para as entradas da segunda camada.
    I[1][0] = O[0][0]*w1_copia[0][0] + O[0][1]*w1_copia[0][1] + O[0][2]*w1_copia[0][2]
    I[1][1] = O[0][0]*w1_copia[1][0] + O[0][1]*w1_copia[1][1] + O[0][2]*w1_copia[1][2]
    I[1][2] = 1.0 # constante.
    #Calculo do Exp para trash_hold.
    O[1][0] = 1.0/(1.0+np.exp(-I[1][0]))
    O[1][1] = 1.0/(1.0+np.exp(-I[1][1]))
    O[1][2] = I[1][2]
    #calculo da ultima entrada
    I[2][0] = O[1][0]*w2_copia[0] + O[1][1]*w2_copia[1] + O[1][2]*w2_copia[2]
    #Calculo da ultima saida
    O[2][0] = 1.0/(1.0+np.exp(-I[2][0]))
    erro +=  (saida[i]-O[2][0]) * (saida[i]-O[2][0])
    saidas.append(round(O[2][0]))
  n+=1
  erro *= 0.5
  diferenca_erro = erro - erro_inicial
  if diferenca_erro < 0.0:
    print(diferenca_erro)
    atualizar_array(w1, w1_copia)
    atualizar_array(w2, w2_copia)
    erro_inicial = erro
    if erro < tx:
      break

print("Epoca: " + str(n))
print("Erro: " + str(erro))
peso1 = []
peso2 = []
peso3 = []
for i in range(w1.shape[1]):
  peso1.append(w1[0][i])
  peso2.append(w1[1][i])
  peso3.append(w2[i])
df_1['W0_inicial'] = peso_comparar_1
df_1['W0_final'] = peso1
df_1['W1_inicial'] = peso_comparar_2
df_1['W1_final'] = peso2
df_1['W2_inicial'] = peso_comparar_3
df_1['W2_final'] = peso3


df_1

df['E1'] = E1
df['E2'] = E2
df['Saidas_esperadas'] = saida
df['Saidas_geradas'] = saidas
df

print(saidas)